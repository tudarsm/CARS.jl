var documenterSearchIndex = {"docs":
[{"location":"howto/","page":"How to...","title":"How to...","text":"CurrentModule = CARS","category":"page"},{"location":"howto/#How-to-...","page":"How to...","title":"How to ...","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"This section gives hints for developers on how to extend functionality to CARS.jl and how to perform typical tasks","category":"page"},{"location":"howto/#...-cite-CARS.jl","page":"How to...","title":"... cite CARS.jl","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"You can cite this publication which describes the method.","category":"page"},{"location":"howto/#...-contribute-to-CARS.jl","page":"How to...","title":"... contribute to CARS.jl","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"Clone the repository\nOpen the root folder (the one containing src/) in VS Code with the Julia extension installed\nOpen a REPL with ALT+J+O (without releasing ALT)\nEnter ] dev . which activates the local repository for development\nStart modifying, commit, push/create PR.","category":"page"},{"location":"howto/#...-build-the-docs-locally-before-pushing-to-the-repo","page":"How to...","title":"... build the docs locally before pushing to the repo","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"Open a command line and navigate to the CARS.jl folder and start julia:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"cd yourLocalCARS.jlFOLDER\njulia --project=docs/","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Then, in Julia, execute the following commands:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"using Revise\nusing Pkg;Pkg.develop(PackageSpec(path=pwd()));Pkg.instantiate();\ninclude(\"docs/make.jl\")","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"This will build the docs in the build directory. Never push this to the repository. It is in the .gitignore file for a reason. Documentations are published to Gitlab/Github pages after pushing to the repository. Leave the command window open and repeat the include(\"docs/make.jl\") command to update the pages.","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"note: Note\nThe first run will probably be very slow. Subsequent runs are blazing fast.","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"To view the newly build documentation, I recommend to use Live Server addon by Ritwick Dey in VSCode. Right click on the index.html (in VSCode) and click Open with Live Server. Upon recreating the docs using the above method, the page automatically reloads.","category":"page"},{"location":"howto/#...-add-more-species","page":"How to...","title":"... add more species","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"In terms of how to generate theoretical susceptibilities, this is way beyond the scope of this documentation and in fact not the job of CARS.jl. If it is a simple diatomic molecule, check out DiaCARS.jl on how these are modelled. For more complex molecules, such as CO2, H2O, NH3, check the relevant literature or come up with your own idea. This is not trivial.","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"If you do have a model for the molecule you are interested in, it can be used in CARS.jl simply using the following:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"using CARS\nimport YourFancyMolecule\n\n# generate a function that is only depending on temperature\nyourfancymolecule(t) = YourFancyMolecule(t,yourmodelparameters,...)\n\n# generate the library (if it is the only species) by passing the function to generateLibrary\nT = 280:5:2000              # temperature range of interest\nlibrary = generateLibrary(T,γc,yourfancymolecule)","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"For this to work, the function has to return the following parameters in exactly that order:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"struct MolParams\n    CHINR::Float64\nend\n\nfunction YourFancyMolecule(t,yourmodelparameters,...)\n\n    # do your simulation here\n\n    # molecularParameters is a struct with at least CHINR per molecule\n    # e.g. for nitrogen, the value is 8.5e-18 cm3/(erg*amagat)\n    # the value that has to be stored is 8.5 / NA * Molvol = 3.1635e-19 (note that the 1e-18 is omitted)\n    # NA = 6.022...e23\n    # Molvol = 2.2413e4\n    # check out DiaCARS.jl for reference\n    molecularParameters = MolParams(1.12345e-19)\n    return χR,χI,ω,species,molecularParameters      \nend\n","category":"page"},{"location":"howto/#...-add-fitting-parameters","page":"How to...","title":"... add fitting parameters","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"To understand how CARS.jl interprets something as a fitting parameter, look at the FitParams struct:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Base.@kwdef mutable struct FitParams\n    T                          # Temperature as value\n    X::Dict{String,Any}        # Dictionary of Mole Fractions of resonant species\n    chiNR=0                      # Non-resonant signal of resonant species. No need to set this manually, will be filled with correct values automatically\n    chiB=8.5                     # Non-resonant susceptibility of the buffer gas    \n    AdditionalFrequencyOffset=0  # For DP CARS Spectra. Additional shift (to what's already in the library) of Pump region 2 relative to pump region 1\n    LineWidth::Dict{String,Any} # Dict of Laser linewidth(s), \"P1\" for pump region 1, \"P2\" for pump region 2\n    Instrumental=0             # Instrumental LineWidth of spectrometer\n    WavenumberPolynomial::Vector{Any}=[2200.,0.5,0.]     # Vector of polynomial parameter to fit the wavenumber axis, Syntax [a, b, c, ..] will be interpreted as a*x^1+b*x^2+c*x^3...\n    WavenumberShift=0          # Shift of calibrated wavenumber axis (zero order)\n    Spectra::SpectraStruct=SpectraStruct([0.],[0.],[0.],[0.],0,\"unknown\")     # After fitting, this will contain the original experimental spectrum (after area normalization) along with the fit\nend","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Furthermore, fit parameters are defined at runtime by specifying a startingsolution as well as upper and lower bounds:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"startingsolution = FitParams(T=800,X=Dict(\"N2\"=>0.7,\"CO2\"=>0.08),LineWidth=Dict(\"P1\"=>0.2,\"P2\"=>.7),AdditionalFrequencyOffset=0,chiB=19.74,Instrumental=1);\nlower=copy(startingsolution);upper=copy(startingsolution);\nlower.X[\"N2\"]=0.6\nupper.X[\"N2\"]=0.75","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"When running in fitting mode, CARS.jl runs these three structs through vectorizeParams! and identifies all fields that have a lower and upper bound differing from the starting solution as a fit parameter. It returns the starting value, lower and upper bound in a vector alongside a loc array which instructs the spectrum generator how to interpret that value, i.e. if it is temperature, mole fraction or another degree of freedom.","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"So in short, to add a new fit parameter, simply add it to the FitParams struct and use it in  calcResidual or  generateSpectrum!. Make sure that the added functionality can handle FowardDiff.Dual, i.e. T<:Real datatypes for the input. Check out the next section for examples how to do that efficiently.","category":"page"},{"location":"howto/#...-add-new-preprocessing","page":"How to...","title":"... add new preprocessing","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"Recall how currently the scheme of loading and preprocessing works:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"signal = load_spectra(\"./src/examples/data/210622A163.SPE\")     # load the signal\nnr = load_spectra(\"./src/examples/data/210622A144.SPE\")         # load the non-resonant signal (e.g. from Argon)\npreprocessed_signals = preprocess_spectra(signal,nr,[600 1000]) # preprocess using defaults","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"preprocess_spectra assumes the datatype RawSpectra and returns an array of PreProcSpectrum. If you want to do fancier preprocessing, such as referencing the signal to single-shot non-resonant signals or different background removals, the only requirement is that the return value of your new preprocessing is also an array of PreProcSpectrum","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"As a default, PreProcSpectrum.w can be [1.], which disables noise weighting. PreProcSpecttrum.ErrorCode can be any value of type Int8. Only those spectra that have a value of 0 here will be evaluated.","category":"page"},{"location":"howto/#...-implement-efficient-handling-of-Duals-for-the-gradient-based-fitter","page":"How to...","title":"... implement efficient handling of Duals for the gradient based fitter","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"warning: Warning\nThis requires some experience with Julia and an understanding of how automatic mode differentiation works. Please make sure you understand what you are planning on doing before you actually do so. Benchmark and validate your implementation before including it in the production version! Before proceeding, read and understand the documentation of ForwardDiff.jl and this section of the JuMP documentation.","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Ok. You now know the requirements of your method to accept T<:Real datatypes and decided to include a new degree of freedom into either one of calcResidual or generateSpectrum!. The need for some trickery really depends on how expensive the computation is. For example, if you just include a vertical shift with a constant number to the entire spectrum, the following is likely totaly fine:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"function addVerticalShift!(spectrum:AbstractArray{T},shift::T) where {T<:Real}\n    @. spectrum += shift\nend","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Note, that for efficiency, this already uses an inplace operation on the variable spectrum, as indicated by the exclamation point in the name of the function. The reason why this naive implementation is unproblematic, is that the sum of two duals is simply summing the value and partials independently. However, more complex functions that operate on multiple arrays, such as convolutions, it is not that straightforward. Using the default DSP.conv() method for example, does not work for Dual numbers. Also, using @tturbo or @avxt from the package LoopVectorizations.jl does not allow using Duals directly. For an example on how to work around this issue, check out this implementation of fastLinearInt:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"function fastLinearInt(wlib::AbstractArray,data::AbstractArray{T},wexp::AbstractArray{T};extrap=false)  where {T<:AbstractFloat} \n    right,left,w = findNeighbours(wexp,wlib,extrap=extrap)\n    interpolated = @avxt @. (w)*data[left]+(1-w)*data[right]\n    return interpolated\nend\n\nfunction fastLinearInt(wlib::AbstractArray{R},data::AbstractArray{<:ForwardDiff.Dual{T,V,K}},wexp::AbstractArray{<:AbstractFloat};extrap=false)  where {R,T,V,K}  \n   # in this function data, is always of dual type\n   # wlib is dual type if wavenumber shift is fitted\n   # wexp is always float here, because dual case is handled in another implementation below\n   \n   # reinterpret values and partials\n   dataE = reinterpret(reshape, V, data)\n\n   # preallocate output array\n   out = Array{eltype(data)}(undef,length(wexp))\n   # and reinterpret it here to fill with data.\n   outE = reinterpret(reshape, V, out)\n\n   if R<:ForwardDiff.Dual\n        wlibE = reinterpret(reshape,V,wlib)\n        # get index where wlibE has a partial derivative of 1.\n        idx = findlast(wlibE[:,1].==1.)\n        # remove the partials, we just need the wavenumber array for interpolation\n        wlibE = wlibE[1,:]\n   else\n        wlibE = wlib\n   end\n   \n   # find neighbors and weights\n   right,left,w,dw = findNeighbours(wexp,wlibE,extrap=extrap)\n\n   # interpolate values and partials\n   @tturbo for i in axes(dataE,1), j in axes(outE,2)\n        outE[i,j] = (w[j])*dataE[i,left[j]]+(1-w[j])*dataE[i,right[j]]\n   end\n\n   # special case: w depends on partial of wlib\n   # so if wlib is a Dual (ie. WavenumberShift is a FitParameter)\n   # account for the partial derivative\n    if R<:ForwardDiff.Dual\n        for j in axes(outE,2)\n                outE[idx,j]=dw*dataE[1,left[j]]-dw*dataE[1,right[j]]\n        end\n    end\n\n   return out   # out has contents of outE!\nend","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"Note a couple of things:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"The implementation makes use of multiple dispatch to decide when to use the method for interpolating an array of Dual or an array of AbstractFloat.\nWe reinterpret the array data::AbstractArray{<:ForwardDiff.Dual} which essentially means, we can manipulate the values and partials of this array explicitly.\nWe prellocate the output out to be the same datatype as data, but with the new length determined by wexp\nThe interpolation is done for both values and partials using this for-loop where the index i iterates over the values and partials and j is the wavenumber direction:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"# interpolate values and partials\n@tturbo for i in axes(dataE,1), j in axes(outE,2)\n    outE[i,j] = (w[j])*dataE[i,left[j]]+(1-w[j])*dataE[i,right[j]]\nend","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"But: one of the partials is the partial derivative with respect to a number that w depends on because we use this function sometimes to fit a wavenumber shift which has an effect on the weights for the interpolation. If we look at the definition of findNeighbours:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"function findNeighbours(wexp,wlib;extrap=false)\n    r=1\n    qp = Array{Int32}(undef,length(wexp))\n    w = Array{Float64}(undef,length(wexp))\n    dw = wlib[2]-wlib[1]\n    # auto detect reversal\n    if wexp[2]>wexp[1]\n        iterator = 1:length(wexp)\n    else\n        iterator = length(wexp):-1:1\n    end\n    for i in iterator\n        for j in r:length(wlib)\n            if wexp[i]<wlib[j]\n                r=j\n                qp[i]=j\n                w[i]=(wlib[j]-wexp[i])/dw\n                break\n            else\n                qp[i]=length(wlib)\n                w[i]=0\n            end\n        end\n    end\n\n    if extrap\n        qp[qp.==1] .= 2\n    end\n    return qp,qp.-1,w,1/dw\nend","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"and have a closer look at this line in the body of the for loop:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"                w[i]=(wlib[j]-wexp[i])/dw","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"we realize, that the derivative of w with respect to wlib (and thus to the wavenumber shift) is simply 1/dw. We can use this to compute the partial derivative as a special case when interpolating our array data for cases where the wavenumber shift is fitted:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"if R<:ForwardDiff.Dual\n    for j in axes(outE,2)\n            outE[idx,j]=dw*dataE[1,left[j]]-dw*dataE[1,right[j]]\n    end\nend","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"tip: More References\nThis is, in the beginning, a little confusing. But it makes a night and day difference for computationally expensive operations. In this example, the speed up between using a naive linear interpolation based on Interpolations.jl and this approach is about a factor of 30 when handling duals. If you would like to see more examples, check out includes/convolutions.jl or includes/fit_spectra.jl. Specifically signalsummation! provides a nice entry point for this way of handling partial derivatives semi-analytically.","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"tip: Tip\nAlways have a fallback solution implemented, at least for verification of your implementation!","category":"page"},{"location":"howto/#...-benchmark-and-validate-your-implementation","page":"How to...","title":"... benchmark and validate your implementation","text":"","category":"section"},{"location":"howto/","page":"How to...","title":"How to...","text":"Since CARS.jl is all about efficiency, you might want to benchmark the adaptions or optimizations you were implementing. You can use the methods benchmarkGradient and benchmarkValue for this, which take the same arguments as gradientFit and blackBoxFit without the options. For example, you can do the following:","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"startingsolution = FitParams(T=800.,X=Dict(\"N2\"=>0.7,\"CO2\"=>0.08,\"O2\"=>0.1),LineWidth=Dict(\"P1\"=>0.7,\"P2\"=>.7),AdditionalFrequencyOffset=-1.,Instrumental=1.,WavenumberShift=-5);\nstartingsolution.WavenumberPolynomial = [2260, 0.285, 0]\nlower=copy(startingsolution);upper=copy(startingsolution);\nlower.X[\"N2\"]=0.6\nupper.X[\"N2\"]=0.75\nlower.X[\"CO2\"]=0.0\nupper.X[\"CO2\"]=0.5\nlower.X[\"O2\"]=0.\nupper.X[\"O2\"]=0.5\nlower.T=300\nupper.T=2200\nlower.Instrumental = 0.5\nupper.Instrumental = 1.5\nlower.LineWidth[\"P1\"]=0.25\nupper.LineWidth[\"P1\"]=0.7\nlower.LineWidth[\"P2\"]=0.25\nupper.LineWidth[\"P2\"]=1.6\nlower.AdditionalFrequencyOffset = -5\nupper.AdditionalFrequencyOffset = 5\nlower.WavenumberPolynomial = [2258, 0.45, 0]\nupper.WavenumberPolynomial = [2263, 0.5, 0]\nlower.WavenumberShift =-6\nupper.WavenumberShift=1\n# run either this:\n@benchmark CARS.benchmarkGradient(spectra[1],startingsolution,lower,upper,lib1,lib2)\n# or this:\n@benchmark CARS.benchmarkValue(spectra[1],startingsolution,lower,upper,lib1,lib2)","category":"page"},{"location":"howto/","page":"How to...","title":"How to...","text":"tip: Validate results\nThe functions return the gradient or value respectively. Use this to ensure that your implementation is done correctly by comparing the results of your optimized implementation and a known reference.","category":"page"},{"location":"allfunctions/#Function-Reference","page":"Function Reference","title":"Function Reference","text":"","category":"section"},{"location":"allfunctions/","page":"Function Reference","title":"Function Reference","text":"Modules = [CARS]","category":"page"},{"location":"allfunctions/#CARS.BlackBoxOptions","page":"Function Reference","title":"CARS.BlackBoxOptions","text":"Base.@kwdef mutable struct BlackBoxOptions\n    MaxFuncEvals::Int = 1000                    # Stop optimizing after reaching this number of iterations\n    TargetFitness::Float64 = 1e-7                 # Stop optimizing after reachting this Fitness level\n    # FitnessTolerance not yet implemented\n    FitnessTolerance::Float64 = 1e-7            # If StoppingCriterion==:tol, stop if change between iterations is lower than this value\n    TraceMode::Symbol = :silent                 # Output of blackboxoptim during optimization, see docs of BlackBoxOptim.jl for choices\n    Method::Symbol = :adaptive_de_rand_1_bin    # Method used for optimization, see docs of BlackBoxOptim.jl for choices\n    StoppingCriterion::Symbol = :best           # If set to :best, iteration will stop if BestFitness is reached. If set to :tol, it will stop if difference between iterations is smaller than FitnessTolerance\n    PopulationSize::Int = 5                    # Population Size for methods which actually use a population. No effect for others.\nend\n\nSpecify options for blackBoxFit\n\n\n\n\n\n","category":"type"},{"location":"allfunctions/#CARS.CARSOptions","page":"Function Reference","title":"CARS.CARSOptions","text":"mutable struct CARSOptions\n\nSpecifies global options that control certain aspects of CARS.jl\n\nfittype::Symbol: either :sqrt to take the square root of the signal intensity (after preprocessing) or anything else (use the signal directly). Affects preprocess_spectra, calcResidual, generateSpectrum! and noiseModel!.\nγf::AbstractFloat: Controls rediscretization after convolution with the compression kernel in generateLibrary and simplifyLibrary!. Higher values means higher resolution of wavenumber axis. Defaults to 5.\ninterp: Control interpolation scheme for some of the operations. Stick with Linear().\nconv_margin: Specifies a safety margin for the convolution with the apparatus function to avoid edge effects after simplifying a library. Applied as a factor to the instrumental linewidth.\n\n\n\n\n\n","category":"type"},{"location":"allfunctions/#CARS.FitParams","page":"Function Reference","title":"CARS.FitParams","text":"Base.@kwdef mutable struct FitParams\n    T                          # Temperature as value\n    X::Dict{String,Any}        # Dictionary of Mole Fractions of resonant species\n    chiNR=0                      # Non-resonant signal of resonant species. No need to set this manually, will be filled with correct values automatically\n    chiB=8.5                     # Non-resonant susceptibility of the buffer gas    \n    AdditionalFrequencyOffset=0  # For DP CARS Spectra. Additional shift (to what's already in the library) of Pump region 2 relative to pump region 1\n    LineWidth::Dict{String,Any} # Dict of Laser linewidth(s), \"P1\" for pump region 1, \"P2\" for pump region 2\n    Instrumental=0             # Instrumental LineWidth of spectrometer\n    WavenumberPolynomial::Vector{Any}=[2200.,0.5,0.]     # Vector of polynomial parameter to fit the wavenumber axis, Syntax [a, b, c] will be interpreted as a+x^1*b+x^2*c\n    WavenumberShift=0          # Shift of calibrated wavenumber axis (zero order)\n    Spectra::SpectraStruct=SpectraStruct([0.],[0.],[0.],[0.],0,\"unknown\")     # After fitting, this will contain the original experimental spectrum (after area normalization) along with the fit\nend\n\nStruct containing all relevant degrees of freedom for simulatin/fitting spectra. Every parameter in here (with the exception of Spectra) can be used in the fit.\n\n\n\n\n\n","category":"type"},{"location":"allfunctions/#CARS.IpoptOptions","page":"Function Reference","title":"CARS.IpoptOptions","text":"Base.@kwdef mutable struct IpoptOptions\n    max_iter::Int = 1000                        # Abort after a certain number of iterations\n    max_wall_time::Float64 = 120.               # Abort after reaching a certain wall time\n    tol::Float64 = 1e-8                         # Abort when reaching this tolerance (see Ipopt Documentation, 1e-7 is the default value)\n    print_level::Int = 3                        # Amount of information during optimization.\n    mu_strategy::String = \"adaptive\"            # \"monotone\" or \"adaptive\".\nend\n\nSpecify options for gradientFit Some options passed to the Ipopt Optimizer. If you wish to extend this, check out the official Ipopt documentation Values in this struct are all passed to the optimizer by name.\n\n\n\n\n\n","category":"type"},{"location":"allfunctions/#CARS.Library","page":"Function Reference","title":"CARS.Library","text":"mutable struct Library\n    species::Vector{String}  # name of resonant species in this library\n    ROI::Vector                 # Region of Interest (excluding extension)\n    AdditionalFrequencyOffset     # FrequencyOffset relative to PumpRegion 1\n    T::Vector           # Vector of temperatures\n    P::Float32          # Pressure\n    ω::Vector{Float32}  # Wavenumberarray after compression\n    ωres::Float32       # Wavenumber resolution used in library\n    γc::Float32          # width of preconvolution kernel\n    χC::Matrix{Array{Float32}} # compressed complex cross-terms\n    χM::Array{Float32} # Compressed magnitude\n    χI::Array{Float32} # Compressed imaginary components\n    χR::Array{Float32} # Compressed real components\n    χNR::Vector{Float32}  # (Purely real) non-resonant susceptibility of species in library. Already converted in cm3/molecule\nend\n\nStruct containing all relevant data for a single pumping region.\n\n\n\n\n\n","category":"type"},{"location":"allfunctions/#CARS.PreProcSpectrum","page":"Function Reference","title":"CARS.PreProcSpectrum","text":"mutable struct PreProcSpectrum\n    I::AbstractVector{Float64}          # area normalized intensity\n    w::AbstractArray{Float64}           # weight used for fit\n    A::Float64                          # original area (used to scale the variance for noise weighting)\n    ErrorCode::Int8                     # specify errorcode after preprocessing (0: no error, 1:saturated, 2: signal too low, 3: breakdown)\nend\n\n\n\n\n\n","category":"type"},{"location":"allfunctions/#CARS.RawSpectra","page":"Function Reference","title":"CARS.RawSpectra","text":"mutable struct RawSpectra\n    I::AbstractArray{Float64}      # signal\n    BG::AbstractArray{Float64}     # background\n    SingleShotNR::AbstractArray{Float64}     # preparation for single shot NR correction. not yet implemented.\nend\n\nStruct containing raw spectra after loading from a file.\n\n\n\n\n\n","category":"type"},{"location":"allfunctions/#CARS.argonModel!-Tuple{Any, Any, Any}","page":"Function Reference","title":"CARS.argonModel!","text":"argonModel!(preprocessed,nr,roi)\n\nExtract a weight based on Stokes noise estimated from measurements in Argon.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.benchmarkGradient-Tuple{PreProcSpectrum, FitParams, FitParams, FitParams, Vararg{CARS.Library, N} where N}","page":"Function Reference","title":"CARS.benchmarkGradient","text":"benchmarkGradient(IE::PreProcSpectrum,startingsolution::FitParams,lower::FitParams,upper::FitParams,libs::Library...)\n\nFunction to compute the gradient of the residual with the same argument structure as the fitting operations. Use e.g with @benchmark or simply @time. Helpful when comparing an optimized handling of an operation on duals with a working reference.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.benchmarkValue-Tuple{PreProcSpectrum, FitParams, FitParams, FitParams, Vararg{CARS.Library, N} where N}","page":"Function Reference","title":"CARS.benchmarkValue","text":"benchmarkValue(IE::PreProcSpectrum,startingsolution::FitParams,lower::FitParams,upper::FitParams,libs::Library...)\n\nFunction to compute the value of the residual with the same argument structure as the fitting operations. Use e.g with @benchmark or simply @time. Helpful when comparing an optimized handling of an operation on duals with a working reference.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.blackBoxFit-Tuple{PreProcSpectrum, FitParams, FitParams, FitParams, Vararg{CARS.Library, N} where N}","page":"Function Reference","title":"CARS.blackBoxFit","text":"blackBoxFit(IE::PreProcSpectrum,startingsolution::FitParams,lower::FitParams,upper::FitParams,libs::Library...;options::BlackBoxOptions=BlackBoxOptions(),showplots=false)\n\nUse BlackBoxOptim.jl for fitting.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.calcResidual-Union{Tuple{T}, Tuple{PreProcSpectrum, Any, FitParams, Any, Vararg{T, N} where N}} where T<:Real","page":"Function Reference","title":"CARS.calcResidual","text":"calcResidual(spec::PreProcSpectrum,libs,params::FitParams,loc,x::T...) where {T<:Real}\n\nCalculates the resiudal between preprocessed experimental spectrum spec and a simulated spectrum defined by params. Requires loc to interpret the vector x as fitting parameters to store in params struct.\n\nnote: Note\nAll methods wihtin this function have to be compatible with T<:Real to be compatible with FowardDiff.Duals!\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.combinedFit-Tuple{PreProcSpectrum, FitParams, FitParams, FitParams, Vararg{CARS.Library, N} where N}","page":"Function Reference","title":"CARS.combinedFit","text":"combinedFit(IE::PreProcSpectrum,startingsolution::FitParams,lower::FitParams,upper::FitParams,libs::Library...;blackboxopt::BlackBoxOptions=BlackBoxOptions(MaxFuncEvals=200,TraceMode=:silent),ipoptopt::IpoptOptions=IpoptOptions(print_level=0),showplots=false) Use blackBoxFit first which provides a starting solution for gradientFit for final fitting.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.fastLinearInt-Union{Tuple{K}, Tuple{V}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N} where N, AbstractArray{var\"#s45\", N} where {var\"#s45\"<:ForwardDiff.Dual{T, V, K}, N}, AbstractArray{var\"#s46\", N} where {var\"#s46\"<:AbstractFloat, N}}} where {R, T, V, K}","page":"Function Reference","title":"CARS.fastLinearInt","text":"fastLinearInt(wlib::AbstractArray{R},data::AbstractArray{<:ForwardDiff.Dual{T,V,K}},wexp::AbstractArray{<:AbstractFloat};extrap=false)  where {R,T,V,K}\n\nDo a fast linear interpolation of a Dual number array data from the original grid wlib to the destination grid wexp.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.findNeighbours-Tuple{Any, Any}","page":"Function Reference","title":"CARS.findNeighbours","text":"findNeighbours(wexp,wlib;extrap=false)\n\nFinds neighbours of each element in wexp in the finer array wlib. Used for fastLinearInt.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.generateLibrary-Tuple{Any, Any, Vararg{Any, N} where N}","page":"Function Reference","title":"CARS.generateLibrary","text":"generateLibrary(T,γc,getSuscs...)\n\nGenerates libraries in the temperature range T, e.g. T=280:20:2000 using the compression kernel γc and the supplied methods getSuscs...\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.generateSpectrum!-Tuple{FitParams, Vararg{Any, N} where N}","page":"Function Reference","title":"CARS.generateSpectrum!","text":"generateSpectrum!(params::FitParams,libs...;takesqrt=CARSopt.fittype)\n\nConvenience function to simulate spectra outside fitting mode.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.generateSpectrum!-Union{Tuple{T}, Tuple{FitParams, T, Any, Vararg{Any, N} where N}} where T<:Real","page":"Function Reference","title":"CARS.generateSpectrum!","text":"generateSpectrum!(params::FitParams,a::T,loc,libs...;takesqrt=CARSopt.fittype) where {T<:Real}\n\nGenerates a spectrum based on the parameters provided by params using the libraries libs.... The loc array is required to identify if some of the degrees of freedom are required, e.g. frequency offset, where the interpolation is not performed if not required.\n\nnote: Note\nAll methods wihtin this function have to be compatible with T<:Real to be compatible with FowardDiff.Duals!\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.gradientFit-Tuple{PreProcSpectrum, FitParams, FitParams, FitParams, Vararg{CARS.Library, N} where N}","page":"Function Reference","title":"CARS.gradientFit","text":"gradientFit(IE::PreProcSpectrum,startingsolution::FitParams,lower::FitParams,upper::FitParams,libs::Library...;options::IpoptOptions=IpoptOptions(),showplots=false)\n\nUse JuMP+Ipopt for fitting.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.isFitParam-Tuple{Any, Any}","page":"Function Reference","title":"CARS.isFitParam","text":"isFitParam(loc,name)\n\nReturns true if name is a fit parameter by detecting if it is in the loc array created by vectorizeParams!\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.noiseModel!-Tuple{Symbol, Vararg{Any, N} where N}","page":"Function Reference","title":"CARS.noiseModel!","text":"noiseModel!(type::Symbol,x...)\n\nAbstraction to extract a noiseModel with various methods. Only implemented at the moment: :argon which calls argonModel!\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.preprocess_spectra-Tuple{RawSpectra, RawSpectra, Any}","page":"Function Reference","title":"CARS.preprocess_spectra","text":"preprocess_spectra(signal::RawSpectra,nr_signal::RawSpectra,roi;errorCriteria::ErrorCriteria=ErrorCriteria())\n\nPreprocesses spectra passed to this function as signal. It uses the some criteria to exclude spectra from fitting, e.g. when the signal is too high or too low or if a breakdown occured. Check out the example fit_experimental_data.jl for how to adapt the ErrorCriteria to your needs. Signals are normalized to the supplied non-resonant signal nr_signal of type RawSpectra and, if specified in CARSOptions the square root is taken.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.save-Tuple{Any, Any, Any}","page":"Function Reference","title":"CARS.save","text":"This function can be used to conveniently store data in either a .MAT or .JLD2 file, depending on what you would like to use for further processing     If the file exists, the data is added to the file.\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.simplifyLibrary!-Tuple{FitParams, Vararg{CARS.Library, N} where N}","page":"Function Reference","title":"CARS.simplifyLibrary!","text":"This function uses the linewidth and additionalfrequencyoffset in fitparams and applies them to the library.     This allows to treat these as fixed parameters for the fit and make it much(!) faster\n\n\n\n\n\n","category":"method"},{"location":"allfunctions/#CARS.vectorizeParams!-Tuple{FitParams, FitParams, FitParams, Tuple}","page":"Function Reference","title":"CARS.vectorizeParams!","text":"vectorizeParams!\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Example Usage","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"This section covers typical examples. More can be found in the src/examples directory of this repository. Just copy them somewhere, install the required packages and run the code.","category":"page"},{"location":"examples/#Generate-Libraries","page":"Example Usage","title":"Generate Libraries","text":"","category":"section"},{"location":"examples/#dp_ss_example","page":"Example Usage","title":"Dual Pump, Single Species per Pump Region","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"In this example, we use DiaCARS to simulate Dual-Pump CARS spectra containing only N2 and O2:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"using CARS\nimport DiaCARS\n## Dual Pump N2/O2-CARS\nROI1 = [2200 2700]              # Pump region 1\nFrequencyOffset = 985;          # Offset for pump region two. Pump1-FrequencyOffset=Region2\nROI2 = ROI1 .- FrequencyOffset  # Pump region 2\nT=280:20:2400                   # Temperature range for library\nγc = 0.1                        # preconvolution kernel\nωres = 5e-4                     # resolution of theoretical susceptibility\nn2_pump1(t) = DiaCARS.simulateTheoreticalSusceptibility(t,\"N2\",1,\"I\",ROI1,ωres) # N2, Pump 1\no2_pump2(t) = DiaCARS.simulateTheoreticalSusceptibility(t,\"O2\",1,\"I\",ROI2,ωres) # O2, Pump 2\n\npump1_library = generateLibrary(T,γc,n2_pump1); \npump2_library = generateLibrary(T,γc,o2_pump2); ","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"You should see an output like this:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Generating a library for species N2 in range 2200.0-2700.0 cm-1\nArray size before compression: 1000001 (Original resolution: 0.0005 cm-1)\nArray size after compression: 25000 (New resolution: 0.020000000298023225 cm-1)\nNumber of required complex cross-terms: 0\nEstimated library size: 31.0 MB\n\n100.0%┣████████████████████████████████┫ 107/107 [00:07<00:00, 15it/s]\n\nGenerating a library for species O2 in range 1215.0-1715.0 cm-1\nArray size before compression: 1000001 (Original resolution: 0.0005 cm-1)\nArray size after compression: 25000 (New resolution: 0.020000000298023225 cm-1)\nNumber of required complex cross-terms: 0\nEstimated library size: 31.0 MB\n\n100.0%┣████████████████████████████████┫107/107 [00:07<00:00, 14it/s]","category":"page"},{"location":"examples/#Generate-Multi-Species-Libraries","page":"Example Usage","title":"Generate Multi-Species Libraries","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"using CARS\nimport DiaCARS\nimport CO2CARS\n## Dual Pump N2/O2-CARS\nROI1 = [2200 2700]              # Pump region 1\nFrequencyOffset = 985;          # Offset for pump region two. Pump1-FrequencyOffset=Region2\nROI2 = ROI1 .- FrequencyOffset  # Pump region 2\nT=280:20:2400                   # Temperature range for library\nγc = 0.1                        # preconvolution kernel\nωres = 5e-4                     # resolution of theoretical susceptibility\nn2_pump1(t) = DiaCARS.simulateTheoreticalSusceptibility(t,\"N2\",1,\"I\",ROI1,ωres) # N2, Pump 1\no2_pump2(t) = DiaCARS.simulateTheoreticalSusceptibility(t,\"O2\",1,\"I\",ROI2,ωres) # O2, Pump 2\nco2_pump2(t) = CO2CARS.simulateTheoreticalSusceptibility(t,1,ROI2,ωres)         # CO2, Pump 2\n\npump1_library = generateLibrary(T,γc,n2_pump1); \npump2_library = generateLibrary(T,γc,o2_pump2,co2_pump2); # Pass as many species here as you like","category":"page"},{"location":"examples/#Simulate-Single-Spectra","page":"Example Usage","title":"Simulate Single Spectra","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Generating spectra is done with generateSpectrum!() together with the FitParams struct and the libraries. This struct contains all physical parameters required for simulating a spectrum and will also be used to provide starting solutions as well as lower and upper bounds for the fitting process later. For this example, use the libraries generated in this example.","category":"page"},{"location":"examples/#Single-Pump","page":"Example Usage","title":"Single Pump","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"As stated in the limitations, single pump spectra are not directly supported yet. But we can workaround this by acknowleding that single-pump CARS is the same as dual-pump CARS with the same region of interest. Simply pass the pump1_library twice to the functions for generating or fitting a spectrum. Make sure to use the same linewidths for both pumping regions.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"exp_params = FitParams(T=2000,X=Dict(\"N2\"=>0.7,),LineWidth=Dict(\"P1\"=>0.7,\"P2\"=>0.7),AdditionalFrequencyOffset=0,chiB=19.74,Instrumental=1);\nωE,IE = generateSpectrum!(exp_params,pump1_library,pump1_library)\nplotSpec(ωE,IE)","category":"page"},{"location":"examples/#Dual-Pump","page":"Example Usage","title":"Dual Pump","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"exp_params = FitParams(T=2000,X=Dict(\"N2\"=>0.7,\"O2\"=>0.2),LineWidth=Dict(\"P1\"=>0.2,\"P2\"=>1),AdditionalFrequencyOffset=0,chiB=19.74,Instrumental=1);\nωE,IE = generateSpectrum!(exp_params,pump1_library,pump2_library)\nplotSpec(ωE,IE)","category":"page"},{"location":"examples/#Fit-Experimental-Spectra","page":"Example Usage","title":"Fit Experimental Spectra","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"danger: Danger\nCreate simulated spectra for this example to avoid dependence on non public CO2CARS.jl","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Supplied in the src/examples/data directory are two files:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"210622A163.SPE contains N2/CO2 CARS spectra\n210622A144.SPE is the non-resonant signal measured before the experiment","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"These samples were recorded at 20 Hz with intermittent capturing of the background for subtraction.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"At first, we load the relevant modules:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"using CARS\nusing Plots\nimport DiaCARS\nimport CO2CARS","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Then, we load the data and plot it for visualization:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"signal = load_spectra(\"./src/examples/data/210622A163.SPE\")\nnr = load_spectra(\"./src/examples/data/210622A144.SPE\")     \nl = @layout [a b;c d]\np1=plot(signal.I)\np2=plot(nr.I)\np3=plot(signal.BG)\np4=plot(nr.BG)\nplot(p1,p2,p3,p4,layout=l,legend=:none)","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Afterwards, we can preprocess the signal which involves background correction with the intermittently recorded background, normalization to the non-resonant background and error checking. For the latter, CARS.jl has reasonable defaults but allows for fine grained control to exclude spectra with too high or too low signal counts and detection of breakdowns. The region of interest [600 1000] in pixel units is used to crop out the desired spectral region.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"note: Note\nAll spectra are normalized to unity area in the region of interest.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"preprocessed_signals = preprocess_spectra(signal,nr,[600 1000];errorCriteria=ErrorCriteria(max_signal=64000,min_signal=1000,breakdown_threshold=1000,breakdown_location=200))\nshowErrorCodes(preprocessed_signals)\n# show the preprocessed spectra\nplot(preprocessed_signals)","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"preprocess_spectra returns an array of PreProcSpectrum containing the preprocessed signals, a vector that can be used for residual weighting during the fit, the ErrorCode and the original area under the spectrum.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"If desired, a noise model can be used to extract the weights for the residual used during the fit to increase precision and accuracy. Check out noiseModel! for possible options:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"noiseModel!(:argon,preprocessed_signals,nr,[600 1000])","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Now we need to generate the libraries:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"ROI1 = [2240 2460]                              # Define Region of Interest for Pump 1\nT = 280:20:2400                                 # Temperature range for which the library is created\nFrequencyOffset = 985                           # Frequency Offset between Pump 1 and Pump 2\nROI2 = ROI1 .- FrequencyOffset                  # Define Region of Interest for Pump 2\nγc = 0.1                                        # preconvolution kernel. has to be smaller than expected linewidth\nωres = 7e-4                                     # resolution for computation of theoretical susceptibility. has to be equal for all species in a given pumping region.\n# Define short handles to functions that generate the desired species' theoretical susceptibilities\n# These basically set everything fixed with the exception of temperature:\nn2(t) = DiaCARS.simulateTheoreticalSusceptibility(t,\"N2\",1,\"I\",ROI1,ωres)     # N2, Pump 1\nco2(t) = CO2CARS.simulateTheoreticalSusceptibility(t,1,ROI2,ωres)             # CO2, Pump 2\n# generate the libraries\nlib1 = generateLibrary(T,γc,n2)    # Create library for pumping region 1 containing N2\nlib2 = generateLibrary(T,γc,co2)   # ... and pumping region2 containing CO2\nlib2org = deepcopy(lib2)\n## hack CO2 model: CARSFT model has severely wrong amplitudes\nfactor = 1.5\nlib2.χM = lib2org.χM * factor^2\nlib2.χR = lib2org.χR * factor\nlib2.χI = lib2org.χI * factor","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Now we can start fitting. As proposed in the publication, it makes sense to determine the instrumental parameters on a spectrum recorded at known conditions or at least conditions, that are steady and allow for averaging out the noise. ","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Is = mean(preprocessed_signals)   # mean spectrum, disables noise weighting","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"CARS.jl is able to fit a second order polynomial to the data, given a decent starting solution which can be extracted by plotting the data and a simulation under approximated/guessed conditions:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"display(plot(Is))     # plot the mean experimental spectrum\nsim = FitParams(T=1000,X=Dict(\"N2\"=>0.7,\"CO2\"=>0.05),LineWidth=Dict(\"P1\"=>0.2,\"P2\"=>.7),Instrumental=1)  \nωE,IE = generateSpectrum!(sim,lib1,lib2);\ndisplay(plot(ωE,IE))  # plot the simulated spectrum","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Now pick two points you would like to closely match pixels to wavenumbers. It does not have to be perfect, we just need a starting solution for the fit. Make sure to just use points from a single pumping region. If your frequency offset is not correctly determined, you will get a bad starting solution. In addition to the points, you need to pass an example spectrum to the function in order to be able to invert the polynomial when converting wavelength to wavenumber.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"wavenumberpolynomial = getWavenumberPolynomial(Is.I,(303,2302),(211,2328),303)","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Now we need to provide a startingsolution, including the generated starting solution for the wavenumberpolynomial:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"startingsolution = FitParams(T=800,X=Dict(\"N2\"=>0.7,\"CO2\"=>0.08),LineWidth=Dict(\"P1\"=>0.2,\"P2\"=>.7),AdditionalFrequencyOffset=0,chiB=19.74,Instrumental=1);\nstartingsolution.WavenumberPolynomial = wavenumberpolynomial","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"To specify, which values are to be fitted, we need to provide lower and upper bounds for the desired parameter. CARS.jl interprets the parameter it is supposed to use for fitting by detecting if the lower and upper bounds differ from the starting solution. If the value is the same, it will not be fitted. If it is not, it will be used as a fit parameter.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"startingsolution = FitParams(T=800,X=Dict(\"N2\"=>0.7,\"CO2\"=>0.08),LineWidth=Dict(\"P1\"=>0.2,\"P2\"=>.7),AdditionalFrequencyOffset=0,chiB=19.74,Instrumental=1);\nstartingsolution.WavenumberPolynomial = wavenumberpolynomial\nlower=copy(startingsolution);upper=copy(startingsolution);\n# define lower and upper bounds\n# set bounds fairly widely for first fit\nlower.X[\"N2\"]=0.6\nupper.X[\"N2\"]=0.75\nlower.X[\"CO2\"]=0.02\nupper.X[\"CO2\"]=0.5\nlower.T = 300\nupper.T = 2400\nlower.Instrumental = 0.5\nupper.Instrumental = 1.5\nlower.LineWidth[\"P1\"]=0.2\nupper.LineWidth[\"P1\"]=0.5\nlower.LineWidth[\"P2\"]=0.2\nupper.LineWidth[\"P2\"]=1.6\nlower.AdditionalFrequencyOffset = -2\nupper.AdditionalFrequencyOffset = 2\nstartingsolution.WavenumberPolynomial = wavenumberpolynomial\n# choosing the bounds of the wavenumber polynomial requires some fiddling in the beginning\n# a good starting point is +- 4 cm-1 for the first element and +- 10% for the second value.\n# the second order term (last element of the array) should be small in the beginning and only\n# increased if the fit hits one of the bounds. start with +- 1e-5\nlower.WavenumberPolynomial = [2270, 0.26, -1e-5]\nupper.WavenumberPolynomial = [2278, 0.3, 1e-5]","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Great. Now we have the libraries, a reference spectrum that we would like to fit and specified the starting solution and the fit parameter bounds. Let's get to it! CARS.jl provides three mechanisms for fitting:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"blackBoxFit uses BlackBoxOptim.jl to do a gradient-free optimization.\ngradientFit uses JuMP+Ipopt to do a gradient-based optimization.\ncombinedFit uses several executions of blackBoxFit to provide a starting solution for gradientFit. This helps avoiding local minima.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"The syntax for all of these is quite similar, and differ only in the optional arguments. Check their documentation for details.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"params=CARS.blackBoxFit(Is,startingsolution,lower,upper,lib1,lib2,options=BlackBoxOptions(MaxFuncEvals=5000),showplots=true)\nparams=CARS.gradientFit(Is,startingsolution,lower,upper,lib1,lib2,options=IpoptOptions(print_level=5,max_wall_time=15),showplots=true);","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"tip: Tip\nThe key to accurate results when fitting single shots is to get the laser linewidths and frequency offset as accurately as possible from these fits. It is possible - however only acceptable when the conditions are well controlled and known - to fix the mole fractions and temperature for this fit to the known values to retrieve the instrumental parameters as close as possible.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"As we know gained the relevant knowledge about our CARS instrument, we can specialize the libraries we generated to include the final laser linewidths and frequency offsets. We do so by creating a copy first and then fixing these values in the library:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"lib1n = deepcopy(lib1)\nlib2n = deepcopy(lib2)\nsimplifyLibrary!(params,lib1n,lib2n)","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Now we can start fitting the single shots and all other experimental data, were these instrumental parameters are applicable to. We again need to define a starting solution. This time, we have to use the results from the first fit, because the correct linewidths and frequency offset are set in this struct. If using another one, the fit might try to refit these parameters. So just use temperature, mole fractions and wavenumber shift:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"startingsolution = deepcopy(params)\n# define upper and lower bounds\nlower=deepcopy(startingsolution);upper=deepcopy(startingsolution);\nlower.X[\"N2\"]=0.6\nupper.X[\"N2\"]=0.75\nlower.X[\"CO2\"]=0.0\nupper.X[\"CO2\"]=0.5\nlower.T = 300\nupper.T = 2400\nlower.WavenumberShift = -1\nupper.WavenumberShift = 1\n# throw off the starting solution for good measure\nstartingsolution.T = 2000\nstartingsolution.X[\"N2\"] = 0.7\nstartingsolution.X[\"CO2\"] = 0.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Now we can start fitting all spectra. The syntax is exactly the same as before. CARS.jl automatically detects the size of the input and uses multiple dispatch to fit the single shots when an array of PreProcSpectrum is passed as the first argument:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"## BLACKBOX\nresults=blackBoxFit(preprocessed_signals,startingsolution,lower,upper,lib1n,lib2n;showplots=true,options=BlackBoxOptions(MaxFuncEvals=10000));\n## GRADIENT\nresults=gradientFit(preprocessed_signals,startingsolution,lower,upper,lib1n,lib2n;showplots=true,options=IpoptOptions(print_level=1,tol=1e-6,max_wall_time=2));\n## COMBINATION\nresults=combinedFit(preprocessed_signals,startingsolution,lower,upper,lib1n,lib2n;showplots=true,ipoptopt=IpoptOptions(print_level=0,tol=1e-6,max_wall_time=2),blackboxopt=BlackBoxOptions(MaxFuncEvals=100));","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Typically, combinedFit will give the best results both in terms of runtime and accurarcy. Note, that showplots=true adds significant overhead to the runtime per spectrum. In many cases, plotting actually is slower than fitting.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"CurrentModule = CARS","category":"page"},{"location":"installation/#Installation-instructions","page":"Installation","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install Julia https://julialang.org/downloads/\nInstall VSCode and the Julia extension\nOpen VSCode and create a new file with .jl extension and saven in a folder that makes sense to you\nOpen a REPL with ALT+J+O (without releasing ALT)\nadd at least CARS.jl and one module to simulate theoretical susceptibilities (such as DiaCARS.jl) with the Package manager. This will install and precompile all necessary packages for you:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"] add https://github.com/tudarsm/cars.jl.git#master\n] add https://github.com/tudarsm/diacars.jl.git#master","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Have a look at the examples provided in the code or this documentation to get started\nIt is planned to add these packages to the Julia registry to simplify the installation","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"note: Note\nThere is no need to clone the packages, unless you actually want to modify CARS.jl itself.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"For more information on using VS Code with Julia, check out https://code.visualstudio.com/docs/languages/julia","category":"page"},{"location":"installation/#How-to-check/update-the-currently-installed-version?","page":"Installation","title":"How to check/update the currently installed version?","text":"","category":"section"},{"location":"installation/#Check-Version","page":"Installation","title":"Check Version","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"] st CARS","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This will return e.g. the following:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(CARS) pkg> st CARS\n[a83ec7ef] CARS v0.2.4 `https://git.rwth-aachen.de/tuda_rsm/cross-sections/cars/jcars/cars.jl.git#master`","category":"page"},{"location":"installation/#Update-Version","page":"Installation","title":"Update Version","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"] up CARS","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CARS","category":"page"},{"location":"#CARS.jl","page":"Home","title":"CARS.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome. This is CARS.jl. If you haven't read the publication yet, please do so. It will answer many of the questions that you may have about what this code does and why.","category":"page"},{"location":"#What-is-CARS.jl?","page":"Home","title":"What is CARS.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CARS.jl is a library-based fitting algorithm for coherent anti-Stokes Raman spectra that features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dual-Pump/Single-Pump evaluation\nHigh processing speed\nHigh accuracy\nAutomatic determination of wavenumber axis using a 2nd order polynomial fitted to the actual data\nIn the libraries, the only tabulated parameter is temperature, thus the size grows (nearly) linearly - not with the power of - the number of species","category":"page"},{"location":"#What-CARS.jl-does","page":"Home","title":"What CARS.jl does","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"generate final spectra from theoretical susceptibilities supplied by other packages, such as DIACars.jl\ngenerate libraries of complex susceptibilities using a loss-less compression scheme for fitting\nfit spectra to experimental data\nsupply several noise models based on shot-noise, Stokes noise and possibly custom noise-models for weighting the residual in the non-linear least squares fit\nstore evaluated data in either JLD2 or MAT format for further data evaluation","category":"page"},{"location":"#What-CARS.jl-does-not-do","page":"Home","title":"What CARS.jl does not do","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generate theoretical susceptibilities. This has to be done using other packages such as DIACARS.jl. This modular structure allows to easily include additional species.","category":"page"},{"location":"#limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CARS.jl assumes independency of theoretical susceptibilities of the mole fractions of other species in the probe volume. This implies that foreign gas broadening is neglected. This is a common approximation and is e.g. also used by CARSFT\nAt present, only fitting at constant pressure are possible. Including pressure in the fit requires introducing pressure variations in the library, because it affects the underlying line shapes.\nSingle Pump CARS is not directly supported at the moment. Simply pass the same library twice (as Single-Pump is actually a special case of Dual-Pump) to the fit/simulation to workaround this limitation. This is likely to be resolved in a future version but does not have the highest priority.","category":"page"},{"location":"#Never-heard-of-Julia?","page":"Home","title":"Never heard of Julia?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Don't worry. Two years ago, I had never heard of Julia before. If this is true, read this. If you are familiar with either MATLAB or Python, you will quickly learn Julia and learn to love it. I promise.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Typical pitfals when coming from either of these languages are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scope of Variables: Variables declared inside a for-loop are not accessible outside the for loop. Declare before the loop.\nJulia arrays are not copied when assigned to another variable. After A=B, changing elements of B will also modify A. This is actually very powerful, but takes some getting used to. If you want a copy, make a copy by using A=copy(B)\nJulia allows unicode variable names, such as χ or symbols for functions, e.g. defining ∗(a,b) = conv(a,b) allows to call the function similar to mathematical notation: c = a∗b\nArrays are indexed with square brackets, A[i,j], not A(i,j)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information, read this article.","category":"page"}]
}
